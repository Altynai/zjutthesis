% !Mode:: "TeX:UTF-8"

\documentclass[translation]{zjutreport}

\graphicspath{{figures/}}  % 定义所有的eps 文件在 figures 子目录下
\begin{document}           % 开始全文

%论文题目：{中文}
\zjuttitle{RAMClouds:可扩展的高性能DRAM存储}
%作者：{中文姓名}{学号}
\zjutauthor{陈佳鹏}{200926630503}
%指导教师：{导师中文名}
\zjutmentor{陈~~~~波}
%个人信息：{毕业年份}{专业名称}
\zjutinfo{2013}{软件工程}
%学院信息：{学院中文}
\zjutcollege{计算机科学与技术学院}
%日期：{提交日期}
\zjutdate{2013年06月}
\input{preface/cover}      % 封面

\frontmatter %应接着命令\begin{document} 使用。它把页码更换为罗马数字，而且章节不计数。

\pagenumbering{Roman}
\begingroup % 在组内的chapter不换行
\let\clearpage\relax % chapter之后不换页



%%%%%%%%%% 标题 %%%%%%%%%%
\titleformat{\chapter}[block]{\sihao\heiti\filcenter\bfseries}{\CJKnumber{\thechapter}}{1ex}{}{} % 标题居中，黑体三号
\chapter*{RAMClouds:可扩展的高性能DRAM存储}
\titleformat{\chapter}[block]{\xiaosi\heiti}{\CJKnumber{\thechapter}、}{1ex}{}{} % 恢复标题居左，黑体四号



%%%%%%%%%% 摘要 %%%%%%%%%%
\include{preface/translation_abstract}     % 中文摘要


%%%%%%%%%% 正文 %%%%%%%%%%
\mainmatter%应出现在书的第一章前面。它启用阿拉伯数字的页码计数器，并对页码重新计数。
\chapter{引言}
四十年来，磁盘
是存储计算机系统中在线信息的主要手段。在此期间磁盘技术经历了巨大的改进，它一直被
更高级别的存储系统利用，
如文件系统和关系数据库。但是，
磁盘的性能并没有像它的容量那样迅速改善
，为了满足大型的Web应用程序的需要，开发人员发现越来越
难测量基于磁盘的系统。很多人都
提出了新的基于磁盘的存储方法来
解决这个问题，另外的人建议用​​闪存设备更换磁盘。相比之下，我们认为，解决的办法是将磁盘中的主要核心数据转移到随机存取存储器上，
磁盘变成备份/归档的角色。

在本文中，我们认为，一类被称为
RAMCloud的新存储将为许多的未来的应用提供存储基底。一个RAMCloud将所有的信息存储在商品服务器的主存储器中，
使用数百或数千个这样的服务器创建一个
大型存储系统。因为任何时候所有的数据都是在
DRAM，RAMCloud可提供基于磁盘的系统、100-1000倍低访问延迟和吞吐量的持久的和可用的存储。虽然个别的
内存是不稳定的，RAMCloud可以使用复制
和备份技术确保数据的耐用性和可用性，这等同于基于磁盘的系统。

我们认为RAMClouds将在三个方面从根本上
改变存储行业的面貌。第一，通过省去了许多的可扩展性问题，这些问题削弱了当今开发人员的工作效率，它们
简化了大型的Web应用程序的开发。第二，
极低的延迟将提供更丰富的查询模型，
提供了一种新的数据密集型应用程序。
第三，RAMClouds将提供需要“云计算”的可扩展存储
基底和其他数据中心的应用程序。一个RAMCloud可以支持一个大型应用程序或许多小应用程序，并允许小型应用程序快速的扩展到大型应用程序，无需为开发人员增加额外的复杂性。


\chapter{RAMCloud概念}
RAMClouds是最有可能被用于在含有大量服务器的数据中心，粗略地划分
分为两类：应用服务器，用来实现应用程序的逻辑，如生成Web页面或执行业务规则；存储服务器，提供长期共享存储的应用程序服务器。传统以来，存储由文件
或关系型数据库组成。但在近年来，为了提高可扩展性，开发出了各种新的存储机制，如Bigtable和memcached。每个数据中心通常支持许多应用，从范围从只有一个应用程序的服务器小应用到千上万的专用应用程序和存储服务器组成的大型应用。

RAMCloud代表了在系统中组织存储服务器一种新的方式。有两个关键属性用来区分RAMCloud和其他存储系统。首先，任何时刻所有的信息都保存在DRAM中。RAMCloud不是像memcached那样的缓存，且数据不是存储在一个I/O设备上，DRAM的数据是永久的家，磁盘仅用于备份。其次，RAMCloud
必须自动扩展以支持数以千计的存储服务器，应用程序看到的是一个单一的存储系统，和存储服务器的实际数目不相关。

\section{并发控制}
由于访问内存比访问磁盘快很多，我们希望在主内存系统中事务能更快处理。在使用锁进行并发控制的系统中，锁不能被占用太久，当数据常驻于磁盘时，锁的竞争可能显得没那么重要。（这里我们专注于基于锁的并发控制，因为这在实践中使用的最多并且已经在MMDB的原型中使用。）

那些通过给小块数据（属性域或记录）加锁的系统就是靠此来减少锁的竞争。因为数据常驻在内存，如果锁的竞争已经不频繁，给小块数据加锁的主要优势实际上已经被忽略了。出于此原因，大块数据（例如关系网）最适合作为常驻内存的数据。

在极端情况下，加锁的小块数据会被当做成整个数据库。这相当于串行执行的事务。串行事物处理是很可取的，因为并发控制的开销几乎完全被忽略了。此外，不通过CPU缓存而直接从原地址获得数据的次数在大幅度减少（每次一个事务暂停并等待锁时，一个新的事务正在运行，CPU缓存中的内容必须被更新。在串行执行的情况下，对于每个事务只需要一个CPU缓存更新器）。在高性能的计算机中，缓存刷新相当于上千条指令，获益非常显着。然而长期事务存在时，串行事务可能是不实际的（例如，对话型交易）。出于公平，运行长期事务时应该以某种方式同步运行短期事务。此外，多处理器系统可能需要某种形式的并发控制，即使都是短期事务。

锁机制的实现也要根据锁定常驻内存的对象而优化。在常规系统中，通过一个包含当前被锁住对象条目的哈希表来实现锁，这些在磁盘上的对象本身不包含锁的信息。如果对象在内存中，我们可能要拿出几位来表示锁的状态。

举例而言，我们只对特别的锁考虑，如果第一位是1则对象被锁，反之。如果前两位都是1，说明有一个乃至更多的事务在等待，这些事务的属性被储存在一个常规的哈希表中。如果一个事务希望锁住一个对象，它首先检查其第一位，如果是0，就置为1，直到处理结束。之后如果另外一个事务想要在这个对象等待，它便将其第二位置为1并将自己加到这个对象的等待队列中。

当处理中的那个事务将第一位置为0时，它检查第二位是否是1。如果不是，说明没有其他事务在等待，结束。如果是，它必须通过常规过程唤醒一个正在等待中的事务。很明显，我们忽略了很多细节问题，但是关键点在于迄今为止，最有可能的情况是一个事务在其他事务等待之前锁住，处理，释放一个对象。在这种情况下，锁住和释放能在最少的机器指令下完成，避免了对整个哈希表的查找。当然必须考虑一个额外的空间开销。对于那些十乃至更多字节的典型数据，几比特的开销就不显得那么重要了。

\section{数据表示}
主内存数据库也能利用有效指针指向数据表示，相关的元组可以被表示成一些指向数据的指针集合。当较大的值在数据库中出现很多次的时候，指针的空间能被有效的利用，因为实际的值只需要储存一次。由于长度可变化的数据能被表示成指向堆内数据的指针，指针简化了处理可变长度字段的问题。

\chapter{系统}
目前，已经提出或实现部分管理内存常驻数据的数据库管理系统，包括纸上设计（MM-DBMS，MARS，HALO）到商业系统测试平台。由于空间有限，我们就做一点短暂的描述。此外，我们将讨论的重点放在“这些系统是如何解决由驻留在内存中的数据引发的问题？”上。

\section{MM-DBMS}
MM-DBMS系统由威斯康星大学设计，和OBE类似，它实现了关系型数据模型并在数据表示和访问方法上广泛的使用指针。可变长度的特征值被表示成指向堆的指针，临时的关系网通过指向数组的指针实现。索引结构的指针直接指向被索引的元组，并不存储实数据，通过一变种线性哈希来索引乱序的数据，而通过T树来访问有序的数据。

出于恢复数据的目的，内存被分割成较大的几块，是用来和磁盘上数据库备份之间传输的单元。提交处理包含稳定的内存（记录日志）和一个单独的恢复处理器，恢复处理器组根据各自引用的记录块可以独立的进行恢复工作。当块内得到了一定数量的更新之后，恢复处理器就会对其进行检查。在检查的过程中会设置一个锁，以确保每个在磁盘上的块保持事务的一致性。备份失败之后，块需要被重新拿回内存并通过其日志记录组做日志记录。

MM-DBMS对大数据颗粒（例如，整个关系网）使用两面锁做并发控制。

\section{MARS}
MARS MMDB由南美以美大学设计，利用一对处理器来对内存常驻数据做快速的事务处理。

MARS系统包括一个数据库处理器和一个恢复处理器，它们能访问一个包含数据库的不稳定主内存和一个稳定的主内存。恢复处理器能访问磁盘的日志记录和数据库的备份副本。

数据库处理器负责事务的执行到事务的提交，除非提交了更新的事务，这些更新不会影响到主数据库的那个备份副本。相反，数据库处理器会记录下稳定内存中的更新。如果更新中的事务中止了，被记录下的更新就被丢弃。

为了提交一个事务，恢复处理器从稳定内存中拷贝其记录下的更新记录到数据库中，这些记录被拷贝到一个稳定的日志缓冲区中。恢复处理器负责刷新整个日志缓冲区到记录日志的磁盘中，同时也定期的做一些检查，将数据库改变的部分刷新到备份中。

也是对大数据颗粒（例如，整个关系网）使用两面锁做并发控制。

\chapter{总结}
在《The 5 minute rule for trading memory for disc 
accesses and the 10 byte rule for trading memory for CPU time》这篇文章中阐述了“每隔5分钟就被引用至少一次的数据应该作为内存常驻数据”这个观点。通过对内存和磁盘数据访问的花费分析，提出了“5分钟”这个数值。重要的一点是，和每秒对磁盘访问的开销相比，主内存每个字节成本在下降，得到结果的时间增加了，也就是说，未来的“5分钟原则”要变成“10分钟原则”了。随着内存越来越便宜，将更多数据永久的保存在内存中是个有效的途径。这意味着在不久的将来，内存数据库系统会变得更加常规化，同时本文中讨论过的机理和优化将变得非常普遍化。

\backmatter %应该插入与书中最后一部分内容的前面，如参考文献和索引。
\endgroup % 组结束



%%%%%%%%%% 参考文献 %%%%%%%%%%
\clearpage % 显式换页，使书签定位准确
\bibliography{references/translation_reference}
\nocite{*}                                   % 若将此命令屏蔽掉，则未引用的文献不会出现在文后的参考文献中。


%%%%%%%%%% 附录 %%%%%%%%%%
%\appendix
%\include{appendix/appendix}            % 附录

\end{document}                                  % 结束全文
